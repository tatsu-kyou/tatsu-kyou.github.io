<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>æ·±åº¦å­¦ä¹ â€”â€”LeNetå·ç§¯ç¥ç»ç½‘ç»œåˆæ¢</title>
    <url>/2024/11/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94LeNet%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="æ¨¡å‹ä»‹ç»ï¼š"><a href="#æ¨¡å‹ä»‹ç»ï¼š" class="headerlink" title="æ¨¡å‹ä»‹ç»ï¼š"></a>æ¨¡å‹ä»‹ç»ï¼š</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94LeNet%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E6%8E%A2/p1.png"
                      alt="image"
                ></p>
<p><strong>ç®€å•ä»‹ç»ï¼š</strong> ä»ç½‘ç»œç»“æ„å¯ä»¥çœ‹å‡ºLeNetå¯¹äºç°åœ¨çš„å¤§æ¨¡å‹æ¥è¯´æ˜¯ä¸€ä¸ªéå¸¸å°çš„ç¥ç»ç½‘ç»œï¼Œä»–ä¸€å…±ç”±7ä¸ªå±‚é¡ºåºè¿æ¥ç»„æˆã€‚<font color="#845EC2">åˆ†åˆ«æ˜¯å·ç§¯å±‚ã€poolingå±‚ã€å·ç§¯å±‚ã€poolingå±‚å’Œä¸‰ä¸ªå…¨è¿æ¥å±‚</font>ã€‚ç”¨ç°ä»£çš„æ·±åº¦å­¦ä¹ æ¡†æ¶æ¥å®ç°ä»£ç å¦‚ä¸‹ï¼š  </p>
<h2 id="ä»£ç å®ç°å’Œè§£è¯»ï¼š"><a href="#ä»£ç å®ç°å’Œè§£è¯»ï¼š" class="headerlink" title="ä»£ç å®ç°å’Œè§£è¯»ï¼š"></a>ä»£ç å®ç°å’Œè§£è¯»ï¼š</h2><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>), nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure></div>

<p><strong>è§£è¯»ï¼š</strong> è¿™ä¸€éƒ¨åˆ†æ˜¯æœ‰å…³ç½‘ç»œçš„å®šä¹‰ï¼Œå¯ä»¥çœ‹å‡ºç½‘ç»œçš„åŸºæœ¬å±‚å®ç°éƒ½è°ƒç”¨äº†torchçš„åº“ï¼Œ<code>sigmoid()</code> å‡½æ•°çš„ä½œç”¨æ˜¯ï¼š<font color="#845EC2">è®©ç½‘ç»œä¸­å„å±‚å åŠ åä¸ä¼šåç¼©ï¼Œå› ä¸ºå¼•å…¥äº†éçº¿æ€§å‡½æ•°ã€‚</font>æˆ‘ä»¬æ¥è¾“å‡ºä¸€ä¸‹ç½‘ç»œçš„å„å±‚çš„ç»“æ„ã€‚</p>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>), dtype=torch.float32)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__, <span class="string">&#x27;output shape: \t:&#x27;</span>, X.shape)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Conv2d output shape: 	: torch.Size([1, 6, 28, 28])</span><br><span class="line">Sigmoid output shape: 	: torch.Size([1, 6, 28, 28])</span><br><span class="line">AvgPool2d output shape: : torch.Size([1, 6, 14, 14])</span><br><span class="line">Conv2d output shape: 	: torch.Size([1, 16, 10, 10])</span><br><span class="line">Sigmoid output shape: 	: torch.Size([1, 16, 10, 10])</span><br><span class="line">AvgPool2d output shape: : torch.Size([1, 16, 5, 5])</span><br><span class="line">Flatten output shape: 	: torch.Size([1, 400])</span><br><span class="line">Linear output shape: 	: torch.Size([1, 120])</span><br><span class="line">Sigmoid output shape: 	: torch.Size([1, 120])</span><br><span class="line">Linear output shape: 	: torch.Size([1, 84])</span><br><span class="line">Sigmoid output shape: 	: torch.Size([1, 84])</span><br><span class="line">Linear output shape: 	: torch.Size([1, 10])</span><br></pre></td></tr></table></figure></div>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬åˆ©ç”¨æ²ç¥çš„<code>d2l</code>åŒ…ä¸­çš„æ•°æ®é›†å‡†å¤‡å‡½æ•°æ¥ä¸‹è½½<code>MNIST</code>æ•°æ®é›†ã€‚</p>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_accuracy_gpu</span>(<span class="params">net, data_iter, device=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, nn.Module):  <span class="comment"># * åˆ¤æ–­å˜é‡çš„ç±»å‹</span></span><br><span class="line">        net.<span class="built_in">eval</span>()          </span><br><span class="line">        <span class="comment">#? å°†ç½‘ç»œè®¾ç½®ä¸ºè¯„ä¼°æ¨¡å¼, åœ¨æ­¤æ¨¡å¼ä¸‹ï¼Œnetä¼šå…³é—­ä¸€äº›ç‰¹å®šçš„è®­ç»ƒæŠ€å·§ä»¥ç¡®ä¿ç½‘ç»œçš„è¡Œä¸ºå’Œè®­ç»ƒæ—¶ä¸€è‡´</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> device:</span><br><span class="line">            device = <span class="built_in">next</span>(<span class="built_in">iter</span>(net.parameters())).device</span><br><span class="line">    metric = d2l.Accumulator(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(X, <span class="built_in">list</span>):</span><br><span class="line">                X = [x.to(device) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                X = X.to(device)  <span class="comment"># * .to(device)æ˜¯ä¸ºäº†å°†æ•°æ®é€è‡³æŒ‡å®šçš„è®¾å¤‡ä¸Šè¿›è¡Œè®¡ç®—</span></span><br><span class="line">            y = y.to(device)</span><br><span class="line">            metric.add(d2l.accuracy(net(X), y), y.numel())</span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">1</span>]  <span class="comment"># * è¿™é‡Œè¿”å›çš„æ˜¯é¢„æµ‹ç²¾åº¦</span></span><br></pre></td></tr></table></figure></div>
<p>ä»¥ä¸Šçš„è¿™æ®µä»£ç çš„å…³é”®æ­¥éª¤æ˜¯<font color="#FF6F91">æ‰§è¡Œäº†.to(device)æ“ä½œï¼Œä¸Šè¿°æ–¹æ³•ä½œç”¨çš„è°ƒç”¨å¯ç”¨çš„GPUè¿›è¡ŒåŠ é€Ÿè¿ç®—</font>ã€‚  </p>
<p>æ¥ä¸‹æ¥è¿™æ®µä»£ç æ˜¯å¯¹netæ‰§è¡Œè®­ç»ƒçš„æ–¹æ³•å®šä¹‰ï¼š  </p>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_ch6</span>(<span class="params">net, train_iter, test_iter, num_epochs, lr, device</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear <span class="keyword">or</span> <span class="built_in">type</span>(m) == nn.Conv2d:</span><br><span class="line">            nn.init.xavier_uniform_(m.weight)  <span class="comment"># ? åˆå§‹åŒ–å‚æ•°</span></span><br><span class="line">            </span><br><span class="line">    net.apply(init_weights)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;training on&#x27;</span>, device)</span><br><span class="line">    net.to(device)</span><br><span class="line">    optimizer = torch.optim.SGD(net.parameters(), lr=lr)</span><br><span class="line">    loss = nn.CrossEntropyLoss()  <span class="comment"># ? äº¤å‰ç†µæŸå¤±å‡½æ•°</span></span><br><span class="line">    animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">3</span>, num_epochs], ylim=[<span class="number">0</span>, <span class="number">2</span>],legend=[<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])</span><br><span class="line">    timer, num_batches = d2l.Timer(), <span class="built_in">len</span>(train_iter)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        metric = d2l.Accumulator(<span class="number">3</span>)</span><br><span class="line">        net.train()  <span class="comment"># ? å°†ç½‘ç»œè®¾ç½®ä¸ºè®­ç»ƒæ¨¡å¼</span></span><br><span class="line">        <span class="keyword">for</span> i, (X, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iter):  <span class="comment"># ? enumerateä¼šè¿”å›ç´¢å¼•åŒæ—¶è¿”å›å¯¹åº”è¿­ä»£æ¬¡æ•°æ—¶çš„å…ƒç´ </span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            X, y = X.to(device), y.to(device)</span><br><span class="line">            y_hat = net(X)</span><br><span class="line">            l = loss(y_hat, y)</span><br><span class="line">            l.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                metric.add(l * X.shape[<span class="number">0</span>], d2l.accuracy(y_hat, y), X.shape[<span class="number">0</span>])</span><br><span class="line">            timer.stop()</span><br><span class="line">            train_l = metric[<span class="number">0</span>] / metric[<span class="number">1</span>]</span><br><span class="line">            train_acc = metric[<span class="number">1</span>] / metric[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>) % (num_batches // <span class="number">5</span>) == <span class="number">0</span> <span class="keyword">or</span> i == num_batches - <span class="number">1</span>:</span><br><span class="line">                animator.add(epoch + (i + <span class="number">1</span>) / num_batches, (train_l, train_acc, <span class="literal">None</span>))</span><br><span class="line">        test_acc = evaluate_accuracy_gpu(net, test_iter)</span><br><span class="line">        animator.add(epoch + <span class="number">1</span>, (<span class="literal">None</span>, <span class="literal">None</span>, test_acc))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;loss <span class="subst">&#123;train_l:<span class="number">.3</span>f&#125;</span>, train acc <span class="subst">&#123;train_acc:<span class="number">.3</span>f&#125;</span>, &#x27;</span> <span class="string">f&#x27;test acc <span class="subst">&#123;test_acc:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;metric[<span class="number">2</span>]*num_epochs / timer.<span class="built_in">sum</span>():<span class="number">.1</span>f&#125;</span> examples/sec &#x27;</span> <span class="string">f&#x27;on <span class="subst">&#123;<span class="built_in">str</span>(device)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>è¿™æ®µä»£ç éå¸¸çš„é•¿ï¼Œæˆ‘ä»¬å°†å…¶åˆ†ä¸ºå‡ ä¸ªéƒ¨åˆ†æ¥è¿›è¡Œè§£è¯»ï¼š  </p>
<p><strong>é¦–å…ˆï¼š</strong>  </p>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear <span class="keyword">or</span> <span class="built_in">type</span>(m) == nn.Conv2d:</span><br><span class="line">        nn.init.xavier_uniform_(m.weight)  <span class="comment"># ? åˆå§‹åŒ–å‚æ•°</span></span><br><span class="line">            </span><br><span class="line">    net.apply(init_weights)</span><br></pre></td></tr></table></figure></div>
<p>è¿™ä¸€æ®µæ‘˜è¦åšçš„æ˜¯ç½‘ç»œ<font color='#FFC75F'>æ‰€æœ‰å‚æ•°çš„åˆå§‹åŒ–</font>ã€‚  </p>
<p><strong>å…¶æ¬¡ï¼š</strong></p>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;training on&#x27;</span>, device)</span><br><span class="line">net.to(device)</span><br><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr=lr)</span><br><span class="line">loss = nn.CrossEntropyLoss()  <span class="comment"># ? äº¤å‰ç†µæŸå¤±å‡½æ•°</span></span><br><span class="line">animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">3</span>, num_epochs], ylim=[<span class="number">0</span>, <span class="number">2</span>],legend=[<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])</span><br><span class="line">timer, num_batches = d2l.Timer(), <span class="built_in">len</span>(train_iter)</span><br></pre></td></tr></table></figure></div>
<p>è¿™ä¸€æ®µä¸»è¦æ˜¯<font color='#FFC75F'>å®šä¹‰äº†ç½‘ç»œè®­ç»ƒå’Œç»“æœå¯è§†åŒ–çš„å¿…è¦å˜é‡ï¼Œå¹¶å°†ç½‘ç»œæ”¾åœ¨GPUä¸Šè¿›è¡Œè¿è¡Œ</font>ã€‚</p>
<p><strong>æ¥ä¸‹æ¥ï¼š</strong></p>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    metric = d2l.Accumulator(<span class="number">3</span>)</span><br><span class="line">    net.train()  <span class="comment"># ? å°†ç½‘ç»œè®¾ç½®ä¸ºè®­ç»ƒæ¨¡å¼</span></span><br><span class="line">    <span class="keyword">for</span> i, (X, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iter):  <span class="comment"># ? enumerateä¼šè¿”å›ç´¢å¼•åŒæ—¶è¿”å›å¯¹åº”è¿­ä»£æ¬¡æ•°æ—¶çš„å…ƒç´ </span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        X, y = X.to(device), y.to(device)</span><br><span class="line">        y_hat = net(X)</span><br><span class="line">        l = loss(y_hat, y)</span><br><span class="line">        l.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            metric.add(l * X.shape[<span class="number">0</span>], d2l.accuracy(y_hat, y), X.shape[<span class="number">0</span>])</span><br><span class="line">        timer.stop()</span><br><span class="line">        train_l = metric[<span class="number">0</span>] / metric[<span class="number">1</span>]</span><br><span class="line">        train_acc = metric[<span class="number">1</span>] / metric[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span>) % (num_batches // <span class="number">5</span>) == <span class="number">0</span> <span class="keyword">or</span> i == num_batches - <span class="number">1</span>:</span><br><span class="line">            animator.add(epoch + (i + <span class="number">1</span>) / num_batches, (train_l, train_acc, <span class="literal">None</span>))</span><br><span class="line">    test_acc = evaluate_accuracy_gpu(net, test_iter)</span><br><span class="line">    animator.add(epoch + <span class="number">1</span>, (<span class="literal">None</span>, <span class="literal">None</span>, test_acc))</span><br></pre></td></tr></table></figure></div>
<p>è¿™ä¸€éƒ¨åˆ†æ˜¯æœ€é‡è¦çš„è®­ç»ƒéƒ¨åˆ†ï¼š<font color='#00C9A7'>å‰å‘ä¼ å¯¼ã€è®¡ç®—æŸå¤±ã€å¯¹æŸå¤±è¿›è¡Œåå‘ä¼ å¯¼å¹¶è®¡ç®—æ¢¯åº¦ã€æ ¹æ®æ¢¯åº¦æ¥æ›´æ–°å‚æ•°</font>ã€‚å¯¹æ¯ä¸€ä¸ªæ ·æœ¬éƒ½è¿›è¡Œä¸Šè¿°çš„åŸºæœ¬è¿‡ç¨‹ã€‚</p>
<p>å‰©ä¸‹çš„éƒ¨åˆ†å°±æ˜¯å¯¹è®­ç»ƒçš„ä¸­é—´è¿‡ç¨‹è¿›è¡Œé€‚å½“çš„è¾“å‡ºã€‚</p>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line">lr, num_epochs = <span class="number">0.9</span>, <span class="number">10</span></span><br><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br></pre></td></tr></table></figure></div>
<p>è¿™æ®µä»£ç æè¿°çš„æ˜¯ç½‘ç»œè®­ç»ƒå™¨ä½¿ç”¨çš„è¿‡ç¨‹ã€‚æ ¹æ®ä¸Šè¿°å‚æ•°å®šä¹‰ï¼Œå¾—åˆ°çš„è®­ç»ƒç»“æœå¦‚ä¸‹å›¾ï¼š</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94LeNet%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E6%8E%A2/p2.png"
                      alt="image"
                ></p>
<h2 id="æ¨¡å‹å±€éƒ¨æœ€ä¼˜åŒ–ï¼š"><a href="#æ¨¡å‹å±€éƒ¨æœ€ä¼˜åŒ–ï¼š" class="headerlink" title="æ¨¡å‹å±€éƒ¨æœ€ä¼˜åŒ–ï¼š"></a>æ¨¡å‹å±€éƒ¨æœ€ä¼˜åŒ–ï¼š</h2><p>æ¥ä¸‹æ¥ï¼Œæˆ‘æƒ³åšçš„æ˜¯ï¼Œåˆ©ç”¨å¾ªç¯å’Œç»“æœå¯è§†åŒ–æ¥æ‰¾åˆ°è¿™ä¸ªæ¨¡å‹ä¸‹çš„å±€éƒ¨æœ€ä¼˜è¶…å‚æ•°ã€‚</p>
<p>â€“ã¤ã¥ã‘</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>ä¸œæ¸¸è®°(ä¸€)--æ­¤è¡Œä¼Šå§‹</title>
    <url>/2024/11/13/Journey-to-the-East1/</url>
    <content><![CDATA[<h3 id="å†™åœ¨æœ€å‰é¢"><a href="#å†™åœ¨æœ€å‰é¢" class="headerlink" title="å†™åœ¨æœ€å‰é¢"></a>å†™åœ¨æœ€å‰é¢</h3><p>æŠ˜è…¾äº†å¥½ä¹…ï¼Œå¯ç®—æ˜¯æŠŠè¿™ä¸ªç®€é™‹çš„åšå®¢å¸¦èµ·æ¥äº†ğŸ¤£ã€‚åˆå›æƒ³èµ·äº†æ—©ä¸¤å¹´è¢«ç¼–ç¨‹ç¯å¢ƒæ”¯é…çš„æ—¥å­äº†ã€‚è¿™æ¬¡çš„åšå®¢æ˜¯åŸºäºGitHubæ­çš„ï¼Œä¹Ÿè®¸æ˜¯æ„Ÿè§‰è¿™æ ·æ¯”åšå®¢å›­æ›´é«˜çº§ï¼Ÿä¹‹å‰ä¹Ÿæ²¡æ€ä¹ˆæ¥è§¦è¿‡ <code>git</code>ï¼Œå°±å½“æ˜¯é¡ºå¸¦å­¦ä¸€ä¸‹äº†ã€‚</p>
<p>ç‰¹æ„å¼€äº†ä¸€ä¸ªæ–°çš„ <code>categories</code> ç”¨æ¥è®°å½• <strong>å››éèœé¸¡å¦‚æˆ‘çš„ä¿®å£«å…»æˆä¹‹è·¯</strong> çš„ã€‚å“ˆå“ˆï¼Œæå¾—å¥½åƒæˆ‘å·²ç»ä¸Šå²¸å¼€å§‹å†™ç»éªŒè´´äº†ä¸€æ ·ï¼Œã‚‚ã†å¤§ä¸ˆå¤«ã ã‹ã‚‰ã€çµ¶å¯¾ã«ä¿®å£«ã«ãªã‚‹ã‚ˆï¼</p>
<h3 id="ä¸ºä»€ä¹ˆå‡ºå‘"><a href="#ä¸ºä»€ä¹ˆå‡ºå‘" class="headerlink" title="ä¸ºä»€ä¹ˆå‡ºå‘"></a>ä¸ºä»€ä¹ˆå‡ºå‘</h3><p>å…¶å®è¿™ä¸ªé—®é¢˜æˆ‘æƒ³äº†å¾ˆä¹…ï¼Œæˆ‘æƒ³ä¿®è€ƒå¦‚æˆ‘çš„å¤§å®¶åº”è¯¥ä¹Ÿæœ‰å¾ˆå¤šä¸åŒçš„åŸå› ã€‚</p>
]]></content>
      <categories>
        <category>ä¸œæ¸¸è®°</category>
      </categories>
      <tags>
        <tag>éšç¬”</tag>
        <tag>è®°å½•</tag>
      </tags>
  </entry>
</search>
